前后端分离架构：前端：app，小程序什么的。后端：mv（视图，模型）
-----------------------------------------------------------------------------------------------------------------------
Flask-RESTful

1、pip install flask-restful

2、 在exts的__init__.py下，创建api对象
from flask_restful import Api  # restful api

# restful api  需要在apps下的__init__初始化
api = Api()

3、在apps的__init__.py下，初始化api
from exts import api

api.init_app(app=app)

4、在视图下
from flask import Blueprint  
from flask_restful import Resource, fields, marshal_with
from exts import api
from apps.blog_app.models import *

# 创建蓝图
restful_bp = Blueprint('restful', __name__, url_prefix='/api')

# 用户表的字段，需跟数据库字段名一致
user_fields = {
    'username': fields.String,
}

# 类视图
class RestfulResource(Resource):
    @marshal_with(user_fields)   # 将返回的数据序列化
    def get(self):
        '''查询'''
        users = User.query.all()
        return users

    def post(self):
        '''增加'''
        return 'post'

    def put(self):
        '''更改'''
        return 'put'

    def delete(self):
        '''删除'''
        return 'deletd'

# api资源（类视图，路径），必须添加，不然访问不到
api.add_resource(RestfulResource, '/rest')

5、前端或postman访问，指定不同请求方式返回不同结果
127.0.0.1：8000/rest
------------------------------------------------------------------------------------------------------------------------
请求解析器reqparse       参考：https://flask-restful.readthedocs.io/en/latest/reqparse.html
from flask_restful import reqparse
from werkzeug.datastructures import FileStorage  # 表单接收图片

# 请求解析，就是表单验证
parser = reqparse.RequestParser(bundle_errors=True)  # bundle_errors=True，会将所有验证不通过的message返回

#                     表单的name            类型         必填         错误返回的信息    只要form表单提交的数据
parser.add_argument(name='username', type=str, required=True, help='用户名', location=['form'])
parser.add_argument(name='password', type=str, required=True, help='密码')

parser.add_argument(name='phone', type=inputs.regex(r'^1[8]\d{9}$'), required=True, help='手机号')  # 使用正则
parser.add_argument('hobby', action='append')  # 接收多个参数，列表形式：['旅游', '打球']
parser.add_argument('icon', type=FileStorage, location='files')  # 接收图片,FileStorage类型

# 类视图
class UsersResource(Resource):
       def post(self):
        '''增加'''
        # 获取经过parser验证的数据
        args = parser.parse_args()
        username = args.get('username')
        password = args.get('password')
        phone = args.get('phone')
        hobby = args.get('hobby')

        # 接收图片并保存
        icon = args.get('icon')
        if icon:
            icon.save(os.path.join(settings.UPLOAD_ICON_DIR, icon.filename))  # 图片保存，里面填路径
        
        return jsonify(username, password, phone, hobby)

-------------------------------------------------
接收图片
from flask_restful import Resource, reqparse


parser = reqparse.RequestParser()


class UsersResource(Resource):
    def post(self):
        '''增加'''
        # 获取post提交数据
        args = parser.parse_args()
       
        return 'ok'
---------------------------------------------------------------------------------------------------------------------
自定义fields的value值，必须继承fields.Raw,必须重写format方法
class isDelete(fields.Raw):
    def format(self, value):
        return '删除' if value else '未删除'

user_fields = {
  .....
    'is_delete': isDelete,  # 使用自定义的fields
}
--------------------------------------------------------------------------------------------------------------------------------
fields.Url，主要参数endpoint

# 使用Url，产生一个链接，点击进入详情，相当于在user_fields前面加了一层
user_fields1 = {
    'username': fields.String,
    'uri': fields.Url(endpoint='single_user', absolute=True),  # endpoint为api的endpoint
}

# 用户表的字段，需跟数据库字段名一致,序列化json返回给前端（get），key默认为模型字段名
user_fields = {
    'id': fields.Integer,

    # 'username': fields.String,
    'name': fields.String(attribute='username', default='匿名'),  # attribute='数据库真实字段名'，为了不给前端显示数据库的字段名
    'register_time': fields.DateTime(dt_format='iso8601'),  # dt_format:日期格式
    'is_delete': isDelete,  # 使用自定义的fields
}


类视图
class UsersResource(Resource):
    @marshal_with(user_fields1)  # 将返回的数据序列化
    def get(self):
        '''查询'''
        users = User.query.all()
        return users

api    
# （类视图，路径），必须添加，不然访问不到
api.add_resource(UsersResource, '/user', endpoint='user')  # endpoint:别名,反向解析url_for()
# 路径传参，用户id，因为上面使用了fields.Url，所以要跟数据库字段一致
api.add_resource(UserResource, '/user/<int:id>', endpoint='single_user')  
















----------------------------------------------------------------------------------------------------------------------------
views.py完整代码
from flask import Blueprint, jsonify
from flask_restful import Resource, fields, marshal_with, reqparse, inputs
from werkzeug.datastructures import FileStorage  # 表单接收图片
from exts import api
from apps.blog_app.models import *
from flask import url_for


# 创建蓝图
restful_bp = Blueprint('restful', __name__, url_prefix='/api')

# 自定义fields的value值，必须继承fields.Raw,必须重写format方法
class isDelete(fields.Raw):
    def format(self, value):
        return '删除' if value else '未删除'

# 使用Url，产生一个链接，点击进入详情，相当于在user_fields前面加了一层
user_fields1 = {
    'username': fields.String,
    'uri': fields.Url(endpoint='single_user', absolute=True),  # endpoint为api的endpoint
}

# 用户表的字段，需跟数据库字段名一致,序列化json返回给前端（get），key默认为模型字段名
user_fields = {
    'id': fields.Integer,

    # 'username': fields.String,
    'name': fields.String(attribute='username', default='匿名'),  # attribute='数据库真实字段名'，为了不给前端显示数据库的字段名

    'register_time': fields.DateTime(dt_format='iso8601'),  # dt_format:日期格式
    'is_delete': isDelete,  # 使用自定义的fields
}

# 请求解析，就是表单验证
parser = reqparse.RequestParser(bundle_errors=True)  # bundle_errors=True，会将所有验证不通过的message返回
#                     表单的name            类型         必填         错误返回的信息    只要form表单提交的数据
parser.add_argument(name='username', type=str, required=True, help='用户名', location=['form'])
parser.add_argument(name='password', type=str, required=True, help='密码', location=['form', 'args'])
parser.add_argument(name='phone', type=inputs.regex(r'^1[8]\d{9}$'), required=True, help='手机号')
parser.add_argument('hobby', action='append')  # 列表形式：['旅游', '打球']
parser.add_argument('icon', type=FileStorage, location='files')  # 接收图片


# 类视图ss
# 对多个用户操作
class UsersResource(Resource):
    @marshal_with(user_fields1)  # 将返回的数据序列化
    def get(self):
        '''查询'''
        users = User.query.all()
        return users

    def post(self):
        '''增加'''
        # 获取post提交数据
        args = parser.parse_args()
        username = args.get('username')
        password = args.get('password')
        phone = args.get('phone')
        hobby = args.get('hobby')
        # 头像
        icon = args.get('icon')
        if icon:
            icon.save(os.path.join(settings.UPLOAD_ICON_DIR, icon.filename))  # 图片保存，里面填路径
        return jsonify(username, password, phone, hobby)

    def put(self):
        '''更改'''
        print('endpoint(别名)的使用：', url_for('uuu'))
        return {'msg': 'ok'}

    def delete(self):
        '''删除'''
        return 'deletd'


# 对单个用户操作，路径传参
class UserResource(Resource):
    @marshal_with(user_fields)  # 将返回的数据序列化
    def get(self, id):
        user = User.query.get(id)
        return user

    def put(self):
        print('***************************************endpoint(别名)的使用：', url_for('uuu'))
        return 'ok'



# （类视图，路径），必须添加，不然访问不到
api.add_resource(UsersResource, '/user', endpoint='user')  # endpoint:别名,反向解析url_for()
api.add_resource(UserResource, '/user/<int:id>', endpoint='single_user')  # 路径传参，用户id


